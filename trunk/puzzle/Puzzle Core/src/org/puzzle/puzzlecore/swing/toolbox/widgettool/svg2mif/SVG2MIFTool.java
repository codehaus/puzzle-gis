/*
 *  Puzzle-GIS - OpenSource mapping program
 *  http://docs.codehaus.org/display/PUZZLEGIS
 *  Copyright (C) 2007-2008 Puzzle-GIS
 *  
 *  GPLv3 + Classpath exception
 *  
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *  
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *  
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.puzzle.puzzlecore.swing.toolbox.widgettool.svg2mif;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.util.Enumeration;
import java.util.Scanner;
import java.util.regex.Pattern;

import javax.swing.JFileChooser;

import javax.swing.JPanel;
import org.geotools.gui.swing.misc.filter.FileFilterFactory;
import org.puzzle.puzzlecore.swing.toolbox.widgettool.svg2mif.element.DCircle;
import org.puzzle.puzzlecore.swing.toolbox.widgettool.svg2mif.element.DLine;
import org.puzzle.puzzlecore.swing.toolbox.widgettool.svg2mif.element.DPoint;
import org.puzzle.puzzlecore.swing.toolbox.widgettool.svg2mif.element.DPolygon;
import org.puzzle.puzzlecore.swing.toolbox.widgettool.svg2mif.element.DRect;
import org.puzzle.puzzlecore.swing.toolbox.widgettool.svg2mif.element.FenetreAide;
import org.puzzle.puzzlecore.swing.toolbox.widgettool.svg2mif.element.mifmidLayer;
import org.puzzle.puzzlecore.swing.toolbox.widgettool.svg2mif.element.polyline;
import org.puzzle.puzzlecore.swing.toolbox.widgettool.svg2mif.element.polylineSection;
import org.puzzle.puzzlecore.swing.toolbox.widgettool.svg2mif.element.xml.Element;
import org.puzzle.puzzlecore.swing.toolbox.widgettool.svg2mif.element.xml.Parser;

/**
 *
 * @author  johann sorel
 */
public class SVG2MIFTool extends JPanel {

    private String fichierSVG;
    private String fichierMIF;
    private mifmidLayer MM;

    /** Creates new form svg2mifPanel */
    public SVG2MIFTool() {
        initComponents();
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPl_fichier_RasterConvUnFichier = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        jBn_fichier_a_conv = new javax.swing.JButton();
        Jtf_Fichier_a_convertir = new javax.swing.JTextField();
        jLabel5 = new javax.swing.JLabel();
        jTF_fichier_en_sortie = new javax.swing.JTextField();
        jBn_fichier_en_sortie = new javax.swing.JButton();
        jPl_Processus_RasterUnFichier = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        jtaOperations = new javax.swing.JTextArea();
        but_demarrer = new javax.swing.JButton();
        jPanel2 = new javax.swing.JPanel();
        jcbTCPoly = new javax.swing.JCheckBox();
        jcbSPoly = new javax.swing.JCheckBox();
        jcbInversion = new javax.swing.JCheckBox();
        jButton1 = new javax.swing.JButton();
        jXTitledSeparator1 = new org.jdesktop.swingx.JXTitledSeparator();

        jPl_fichier_RasterConvUnFichier.setBorder(javax.swing.BorderFactory.createTitledBorder(org.openide.util.NbBundle.getMessage(SVG2MIFTool.class, "file"))); // NOI18N

        jLabel1.setText(org.openide.util.NbBundle.getMessage(SVG2MIFTool.class, "input_file")); // NOI18N

        jBn_fichier_a_conv.setText("...");
        jBn_fichier_a_conv.setPreferredSize(new java.awt.Dimension(45, 20));
        jBn_fichier_a_conv.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jBn_fichier_a_convclic_fichier_source(evt);
            }
        });

        Jtf_Fichier_a_convertir.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                Jtf_Fichier_a_convertiractionChangementSource(evt);
            }
        });

        jLabel5.setText(org.openide.util.NbBundle.getBundle(SVG2MIFTool.class).getString("output_file")); // NOI18N

        jTF_fichier_en_sortie.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jTF_fichier_en_sortieactionChangementDestination(evt);
            }
        });
        jTF_fichier_en_sortie.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusLost(java.awt.event.FocusEvent evt) {
                jTF_fichier_en_sortieactionChangementDestination2(evt);
            }
        });

        jBn_fichier_en_sortie.setText("...");
        jBn_fichier_en_sortie.setPreferredSize(new java.awt.Dimension(45, 20));
        jBn_fichier_en_sortie.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jBn_fichier_en_sortieclic_fichier_destination(evt);
            }
        });

        org.jdesktop.layout.GroupLayout jPl_fichier_RasterConvUnFichierLayout = new org.jdesktop.layout.GroupLayout(jPl_fichier_RasterConvUnFichier);
        jPl_fichier_RasterConvUnFichier.setLayout(jPl_fichier_RasterConvUnFichierLayout);
        jPl_fichier_RasterConvUnFichierLayout.setHorizontalGroup(
            jPl_fichier_RasterConvUnFichierLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(jPl_fichier_RasterConvUnFichierLayout.createSequentialGroup()
                .addContainerGap()
                .add(jPl_fichier_RasterConvUnFichierLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(jLabel5, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 270, Short.MAX_VALUE)
                    .add(jLabel1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 270, Short.MAX_VALUE)
                    .add(org.jdesktop.layout.GroupLayout.TRAILING, jPl_fichier_RasterConvUnFichierLayout.createSequentialGroup()
                        .add(jPl_fichier_RasterConvUnFichierLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING)
                            .add(jTF_fichier_en_sortie, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 219, Short.MAX_VALUE)
                            .add(Jtf_Fichier_a_convertir, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 219, Short.MAX_VALUE))
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(jPl_fichier_RasterConvUnFichierLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                            .add(org.jdesktop.layout.GroupLayout.TRAILING, jBn_fichier_a_conv, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                            .add(org.jdesktop.layout.GroupLayout.TRAILING, jBn_fichier_en_sortie, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))))
                .addContainerGap())
        );
        jPl_fichier_RasterConvUnFichierLayout.setVerticalGroup(
            jPl_fichier_RasterConvUnFichierLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(jPl_fichier_RasterConvUnFichierLayout.createSequentialGroup()
                .add(jLabel1)
                .add(7, 7, 7)
                .add(jPl_fichier_RasterConvUnFichierLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(jBn_fichier_a_conv, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                    .add(Jtf_Fichier_a_convertir, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(jLabel5)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(jPl_fichier_RasterConvUnFichierLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(jBn_fichier_en_sortie, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                    .add(jTF_fichier_en_sortie, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                .addContainerGap())
        );

        jPl_Processus_RasterUnFichier.setBorder(javax.swing.BorderFactory.createTitledBorder(org.openide.util.NbBundle.getMessage(SVG2MIFTool.class, "process"))); // NOI18N

        jtaOperations.setColumns(20);
        jtaOperations.setRows(5);
        jScrollPane1.setViewportView(jtaOperations);

        org.jdesktop.layout.GroupLayout jPl_Processus_RasterUnFichierLayout = new org.jdesktop.layout.GroupLayout(jPl_Processus_RasterUnFichier);
        jPl_Processus_RasterUnFichier.setLayout(jPl_Processus_RasterUnFichierLayout);
        jPl_Processus_RasterUnFichierLayout.setHorizontalGroup(
            jPl_Processus_RasterUnFichierLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(jScrollPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 290, Short.MAX_VALUE)
        );
        jPl_Processus_RasterUnFichierLayout.setVerticalGroup(
            jPl_Processus_RasterUnFichierLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(jScrollPane1)
        );

        but_demarrer.setText(org.openide.util.NbBundle.getMessage(SVG2MIFTool.class, "convert")); // NOI18N
        but_demarrer.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                but_demarreractionDemarrer(evt);
            }
        });

        jPanel2.setBorder(javax.swing.BorderFactory.createTitledBorder(org.openide.util.NbBundle.getMessage(SVG2MIFTool.class, "config"))); // NOI18N

        jcbTCPoly.setText("Tout en polygone"); // NOI18N
        jcbTCPoly.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));

        jcbSPoly.setText("Que les polygones"); // NOI18N
        jcbSPoly.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));

        jcbInversion.setText("Inversion coordonnées verticales");
        jcbInversion.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));

        org.jdesktop.layout.GroupLayout jPanel2Layout = new org.jdesktop.layout.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .add(jPanel2Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(jcbTCPoly)
                    .add(jcbSPoly)
                    .add(jcbInversion))
                .addContainerGap(103, Short.MAX_VALUE))
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(jPanel2Layout.createSequentialGroup()
                .add(jcbTCPoly)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(jcbSPoly)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(jcbInversion)
                .addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        jButton1.setText(org.openide.util.NbBundle.getMessage(SVG2MIFTool.class, "help")); // NOI18N
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                afficherAide(evt);
            }
        });

        jXTitledSeparator1.setTitle(org.openide.util.NbBundle.getMessage(SVG2MIFTool.class, "title")); // NOI18N

        org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(org.jdesktop.layout.GroupLayout.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING)
                    .add(org.jdesktop.layout.GroupLayout.LEADING, jPl_Processus_RasterUnFichier, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .add(layout.createSequentialGroup()
                        .add(jButton1)
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(but_demarrer))
                    .add(org.jdesktop.layout.GroupLayout.LEADING, jXTitledSeparator1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 306, Short.MAX_VALUE)
                    .add(org.jdesktop.layout.GroupLayout.LEADING, jPl_fichier_RasterConvUnFichier, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .add(org.jdesktop.layout.GroupLayout.LEADING, jPanel2, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(layout.createSequentialGroup()
                .addContainerGap()
                .add(jXTitledSeparator1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(jPl_fichier_RasterConvUnFichier, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(jPanel2, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(jPl_Processus_RasterUnFichier, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(but_demarrer)
                    .add(jButton1))
                .addContainerGap())
        );
    }// </editor-fold>//GEN-END:initComponents
    private void afficherAide(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_afficherAide
        // Appel de la page d'aide
        FenetreAide jfAide = new FenetreAide();
        jfAide.setVisible(true);
    }//GEN-LAST:event_afficherAide

    private void but_demarreractionDemarrer(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_but_demarreractionDemarrer
        fichierSVG = Jtf_Fichier_a_convertir.getText();
        fichierMIF = jTF_fichier_en_sortie.getText();

        ouverture(fichierSVG);
        ecriture(fichierMIF);
    }//GEN-LAST:event_but_demarreractionDemarrer

    private void jBn_fichier_en_sortieclic_fichier_destination(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jBn_fichier_en_sortieclic_fichier_destination
        JFileChooser explorateurDestination = new JFileChooser();
        explorateurDestination.addChoosableFileFilter(FileFilterFactory.createFileFilter(FileFilterFactory.FORMAT.MAPINFO_EXCHANGE));

        explorateurDestination.setFileFilter(explorateurDestination.getChoosableFileFilters()[1]);

        int valeur2 = explorateurDestination.showSaveDialog(this);

        if (valeur2 == JFileChooser.APPROVE_OPTION) {
            jTF_fichier_en_sortie.setText(explorateurDestination.getSelectedFile().getPath());
            verification();
        }
    }//GEN-LAST:event_jBn_fichier_en_sortieclic_fichier_destination

    private void jTF_fichier_en_sortieactionChangementDestination2(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jTF_fichier_en_sortieactionChangementDestination2
        verification();
    }//GEN-LAST:event_jTF_fichier_en_sortieactionChangementDestination2

    private void jTF_fichier_en_sortieactionChangementDestination(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jTF_fichier_en_sortieactionChangementDestination
        verification();
    }//GEN-LAST:event_jTF_fichier_en_sortieactionChangementDestination

    private void Jtf_Fichier_a_convertiractionChangementSource(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_Jtf_Fichier_a_convertiractionChangementSource
        verification();
    }//GEN-LAST:event_Jtf_Fichier_a_convertiractionChangementSource

    private void jBn_fichier_a_convclic_fichier_source(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jBn_fichier_a_convclic_fichier_source
        JFileChooser explorateur = new JFileChooser();
        explorateur.addChoosableFileFilter(FileFilterFactory.createFileFilter(FileFilterFactory.FORMAT.SCALABLE_VECTOR_GRAPHICS));

        explorateur.setFileFilter(explorateur.getChoosableFileFilters()[1]);
        int valeur = explorateur.showOpenDialog(this);
        if (valeur == JFileChooser.APPROVE_OPTION) {

            //explorateur.getSelectedFile().getPath();
            Jtf_Fichier_a_convertir.setText(explorateur.getSelectedFile().getPath());
            verification();

        }
    }//GEN-LAST:event_jBn_fichier_a_convclic_fichier_source

    private void verification() {
        String nom_sortie = jTF_fichier_en_sortie.getText();
        String nom_entree = Jtf_Fichier_a_convertir.getText();
        String extension_fichier = "";
        String extension_liste = ".mif";
        String nouveaunom = "";
        int index = -1;

        //si le texte en sortie est vide on le complete avec celui d'entree
        if (nom_sortie.length() == 0) {
            nom_sortie = nom_entree;
        }

        //recuperation de l'extension du fichier en sortie
        index = nom_sortie.lastIndexOf(".");
        if (index != -1) {
            extension_fichier = nom_sortie.substring(index, nom_sortie.length());
        }


        // on corrige l'extension
        if (!nom_sortie.endsWith(extension_liste)) {

            if (nom_sortie.endsWith(File.separator)) {
                nom_sortie += "sortie.mif";
            }

            if (!nom_sortie.equals("")) {
                if (index == -1) {

                    nouveaunom = nom_sortie + extension_liste;
                } else {
                    nouveaunom = nom_sortie.substring(0, index) + extension_liste;
                }
            }

        } else {
            nouveaunom = nom_sortie;
        }

        jTF_fichier_en_sortie.setText(nouveaunom);
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTextField Jtf_Fichier_a_convertir;
    private javax.swing.JButton but_demarrer;
    private javax.swing.JButton jBn_fichier_a_conv;
    private javax.swing.JButton jBn_fichier_en_sortie;
    private javax.swing.JButton jButton1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPl_Processus_RasterUnFichier;
    private javax.swing.JPanel jPl_fichier_RasterConvUnFichier;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTextField jTF_fichier_en_sortie;
    private org.jdesktop.swingx.JXTitledSeparator jXTitledSeparator1;
    private javax.swing.JCheckBox jcbInversion;
    private javax.swing.JCheckBox jcbSPoly;
    private javax.swing.JCheckBox jcbTCPoly;
    private javax.swing.JTextArea jtaOperations;
    // End of variables declaration//GEN-END:variables
    public void ouverture(String fichierSVG) {
        // Lecture SVG

        String ligne;

        try {
            MM = new mifmidLayer(fichierMIF);
            jtaOperations.setText("Opening SVG\\n");
            Parser SVGParser = new Parser(fichierSVG);
            Enumeration SVGe = SVGParser.getElements();
            Element eec = new Element();
            while (SVGe.hasMoreElements()) {
                eec = (Element) SVGe.nextElement();
                jtaOperations.setText(jtaOperations.getText() + eec.getTagName() + "\n");
                if (eec.getTagName().equals("svg")) {
                    if (eec.hasAttribute("width")) {
                    // MM.setSize(new
                    // DDimension(getValueFromSize(eec.getAttribute("width")),
                    // getValueFromSize(eec.getAttribute("height"))));
                    // MM.setSizeUnit(getUnitFromSize(eec.getAttribute("width")));
                    }
                // jtaOperations.setText(jtaOperations.getText() +
                // MM.getSize().toString() + "\n");
                }
                String tn = eec.getTagName();
                if (!tn.equals("polygon") && !this.jcbSPoly.isSelected()) {
                    if (tn.equals("path") || tn.equals("PATH")) {
                        processPath(eec);
                    }
                    if (tn.equals("rect") || tn.equals("RECT")) {
                        processRect(eec);
                    }
                    if (tn.equals("line") || tn.equals("LINE")) {
                        processLine(eec);
                    }
                    if (tn.equals("polyline") || tn.equals("POLYLINE")) {
                        processPolyline(eec);
                    }
                    if (tn.equals("circle") || tn.equals("CIRCLE")) {
                        processCircle(eec);
                    }
                    if (tn.equals("ellipse") || tn.equals("ELLIPSE")) {
                        processEllipse(eec);
                    }
                }

                if (tn.equals("polygon") || tn.equals("POLYGON")) {
                    processPolygon(eec);
                }
            }
        // tampon.close();
        }/*
         * catch (FileNotFoundException e) { // Exception d�clench�e si le
         * fichier n'existe pas
         * System.out.println(Messages.getString("Dialogue.fileNotExist"));
         * //$NON-NLS-1$ } catch (EOFException e) { // Exception d�clench�e
         * si la fin du fichier est atteinte
         * System.out.println(Messages.getString("Dialogue.eof"));
         * //$NON-NLS-1$ } catch (IOException e) { // Exception d�clench�e
         * si un autre probl�me survient // pendant l'acc�s au fichier
         * System.out.println(Messages.getString("Dialogue.IOerror"));
         * //$NON-NLS-1$ }
         */ finally {
            // Pas d'erreur rencontr�e
            jtaOperations.setText(jtaOperations.getText() + "Converted objets : ok");
        }
    }

    private void processPath(Element eec) {
        if (eec.hasAttribute("d") == false) {
            // Erreur irr�cup�rable
            return;
        }
        if (!this.jcbTCPoly.isSelected()) {
            DPoint premierPoint = new DPoint(0, 0);
            DPoint pt = new DPoint(0, 0);
            polyline pl = new polyline();
            String d = eec.getAttribute("d");
            Pattern p = Pattern.compile("\\s+|,");
            Scanner s = new Scanner(d).useDelimiter(p);
            while (s.hasNext()) {
                String e = s.next();
                String last = "";
                if (e.equals("M")) {
                    polylineSection ps = new polylineSection();
                    pt.x = Double.parseDouble(s.next());
                    pt.y = Double.parseDouble(s.next());
                    ps.addPoint((DPoint) pt.clone());
                    premierPoint = (DPoint) pt.clone();
                    e = s.next();
                    while (e.toLowerCase().equals("z") != true) {
                        if (e.equals("M")) {
                            ps.addPoint((DPoint) premierPoint.clone());
                            pl.addSection((polylineSection) ps.clone());
                            ps = new polylineSection();
                            pt.x = Double.parseDouble(s.next());
                            pt.y = Double.parseDouble(s.next());
                            premierPoint = (DPoint) pt.clone();
                            verifBounds(pt);
                            ps.addPoint((DPoint) pt.clone());
                        }
                        if (e.equals("m")) {
                            ps.addPoint((DPoint) premierPoint.clone());
                            pl.addSection((polylineSection) ps.clone());
                            ps = new polylineSection();
                            pt.x += Double.parseDouble(s.next());
                            pt.y += Double.parseDouble(s.next());
                            premierPoint = (DPoint) pt.clone();
                            verifBounds(pt);
                            ps.addPoint((DPoint) pt.clone());
                        }
                        if (e.equals("L")) {
                            pt.x = Double.parseDouble(s.next());
                            pt.y = Double.parseDouble(s.next());
                            verifBounds(pt);
                            ps.addPoint((DPoint) pt.clone());
                            last = "L";
                        } else if (e.equals("l")) {
                            pt.x += Double.parseDouble(s.next());
                            pt.y += Double.parseDouble(s.next());
                            verifBounds(pt);
                            ps.addPoint((DPoint) pt.clone());
                            last = "l";
                        } else {
                            pt.x = Double.parseDouble(e);
                            pt.y = Double.parseDouble(s.next());
                            verifBounds(pt);
                            ps.addPoint((DPoint) pt.clone());
                        }
                        if (s.hasNext()) {
                            e = s.next();
                        } else {
                            e = "z";
                        }
                    }
                    ps.addPoint((DPoint) premierPoint.clone());
                    pl.addSection((polylineSection) ps.clone());
                    MM.addObject(pl);
                }
            }
        } else {
            DPolygon po = new DPolygon();
            DPoint premierPoint = new DPoint(0, 0);
            DPoint pt = new DPoint(0, 0);
            DPoint[] bounds = {new DPoint(Double.MAX_VALUE, Double.MAX_VALUE),
                new DPoint(Double.MIN_VALUE, Double.MIN_VALUE)
            };
            String d = eec.getAttribute("d");
            Pattern p = Pattern.compile("\\s+|,");
            Scanner s = new Scanner(d).useDelimiter(p);
            while (s.hasNext()) {
                String e = s.next();
                if (e.equals("M")) {
                    pt.x = Double.parseDouble(s.next());
                    pt.y = Double.parseDouble(s.next());
                    po.addPoint((DPoint) pt.clone());
                    premierPoint = (DPoint) pt.clone();
                    e = s.next();
                    while (e.toLowerCase().equals("z") != true) {
                        if (e.equals("M")) {
                            po.addPoint((DPoint) premierPoint.clone());
                            DPoint center = new DPoint(0, 0);
                            center.x = (bounds[0].x + bounds[1].x) / 2;
                            center.y = (bounds[0].y + bounds[1].y) / 2;
                            po.setCenter((DPoint) center.clone());
                            MM.addObject(po.clone());
                            bounds[0] = new DPoint(Double.MAX_VALUE, Double.MAX_VALUE);
                            bounds[1] = new DPoint(Double.MIN_VALUE, Double.MIN_VALUE);
                            po = new DPolygon();
                            pt.x = Double.parseDouble(s.next());
                            pt.y = Double.parseDouble(s.next());
                            premierPoint = (DPoint) pt.clone();
                            verifBoundsP(pt, bounds);
                            verifBounds(pt);
                            po.addPoint((DPoint) pt.clone());
                        }
                        if (e.equals("m")) {
                            po.addPoint((DPoint) premierPoint.clone());
                            DPoint center = new DPoint(0, 0);
                            center.x = (bounds[0].x + bounds[1].x) / 2;
                            center.y = (bounds[0].y + bounds[1].y) / 2;
                            po.setCenter((DPoint) center.clone());
                            MM.addObject(po.clone());
                            bounds[0] = new DPoint(Double.MAX_VALUE, Double.MAX_VALUE);
                            bounds[1] = new DPoint(Double.MIN_VALUE, Double.MIN_VALUE);
                            po = new DPolygon();
                            pt.x += Double.parseDouble(s.next());
                            pt.y += Double.parseDouble(s.next());
                            premierPoint = (DPoint) pt.clone();
                            verifBoundsP(pt, bounds);
                            verifBounds(pt);
                            po.addPoint((DPoint) pt.clone());
                        }
                        if (e.equals("L")) {
                            pt.x = Double.parseDouble(s.next());
                            pt.y = Double.parseDouble(s.next());
                            verifBoundsP(pt, bounds);
                            verifBounds(pt);
                            po.addPoint((DPoint) pt.clone());
                        } else if (e.equals("l")) {
                            pt.x += Double.parseDouble(s.next());
                            pt.y += Double.parseDouble(s.next());
                            verifBoundsP(pt, bounds);
                            verifBounds(pt);
                            po.addPoint((DPoint) pt.clone());
                        } else {
                            pt.x += Double.parseDouble(e);
                            pt.y += Double.parseDouble(s.next());
                            verifBoundsP(pt, bounds);
                            verifBounds(pt);
                            po.addPoint((DPoint) pt.clone());
                        }
                        if (s.hasNext()) {
                            e = s.next();
                        } else {
                            e = "z";
                        }
                    }
                    DPoint center = new DPoint(0, 0);
                    center.x = (bounds[0].x + bounds[1].x) / 2;
                    center.y = (bounds[0].y + bounds[1].y) / 2;
                    po.setCenter((DPoint) center.clone());
                    po.addPoint((DPoint) premierPoint.clone());
                    MM.addObject(po.clone());
                }
            }
        }
    }

    private void processRect(Element eec) {
        if (eec.hasAttribute("x") == false) {
            // Erreur irr�cup�rable
            return;
        }
        if (!this.jcbTCPoly.isSelected()) {
            double x1, y1, x2, y2;
            x1 = Double.parseDouble(eec.getAttribute("x"));
            y1 = Double.parseDouble(eec.getAttribute("y"));
            verifBounds(new DPoint(x1, y1));
            x2 = x1 + getValueFromSize(eec.getAttribute("width"));
            y2 = y1 + getValueFromSize(eec.getAttribute("height"));
            verifBounds(new DPoint(x2, y2));
            DRect r = new DRect(x1, y1, x2, y2);
            MM.addObject(r);
        } else {
            double x1, y1, x2, y2;
            DPolygon po = new DPolygon();
            DPoint[] bounds = {new DPoint(Double.MAX_VALUE, Double.MAX_VALUE),
                new DPoint(Double.MIN_VALUE, Double.MIN_VALUE)
            };
            x1 = Double.parseDouble(eec.getAttribute("x"));
            y1 = Double.parseDouble(eec.getAttribute("y"));
            verifBoundsP(new DPoint(x1, y1), bounds);
            verifBounds(new DPoint(x1, y1));
            x2 = x1 + getValueFromSize(eec.getAttribute("width"));
            y2 = y1 + getValueFromSize(eec.getAttribute("height"));
            verifBoundsP(new DPoint(x2, y2), bounds);
            verifBounds(new DPoint(x2, y2));
            po.addPoint(new DPoint(x1, y1));
            po.addPoint(new DPoint(x2, y1));
            po.addPoint(new DPoint(x2, y2));
            po.addPoint(new DPoint(x1, y2));
            po.addPoint(new DPoint(x1, y1));
            DPoint center = new DPoint(0, 0);
            center.x = (bounds[0].x + bounds[1].x) / 2;
            center.y = (bounds[0].y + bounds[1].y) / 2;
            po.setCenter((DPoint) center.clone());
            MM.addObject(po);
        }
    }

    private void processLine(Element eec) {
        if (eec.hasAttribute("x1") == false) {
            // Erreur irr�cup�rable
            return;
        }
        if (!this.jcbTCPoly.isSelected()) {
            double x1, y1, x2, y2;
            x1 = Double.parseDouble(eec.getAttribute("x1"));
            y1 = Double.parseDouble(eec.getAttribute("y1"));
            verifBounds(new DPoint(x1, y1));
            x2 = getValueFromSize(eec.getAttribute("x2"));
            y2 = getValueFromSize(eec.getAttribute("y2"));
            verifBounds(new DPoint(x2, y2));
            DLine l = new DLine(x1, y1, x2, y2);
            MM.addObject(l);
        } else {
            double x1, y1, x2, y2;
            DPolygon po = new DPolygon();
            DPoint[] bounds = {new DPoint(Double.MAX_VALUE, Double.MAX_VALUE),
                new DPoint(Double.MIN_VALUE, Double.MIN_VALUE)
            };
            x1 = Double.parseDouble(eec.getAttribute("x1"));
            y1 = Double.parseDouble(eec.getAttribute("y1"));
            verifBoundsP(new DPoint(x1, y1), bounds);
            verifBounds(new DPoint(x1, y1));
            x2 = getValueFromSize(eec.getAttribute("x2"));
            y2 = getValueFromSize(eec.getAttribute("y2"));
            verifBoundsP(new DPoint(x2, y2), bounds);
            verifBounds(new DPoint(x2, y2));
            po.addPoint(new DPoint(x1, y1));
            po.addPoint(new DPoint(x2, y1));
            po.addPoint(new DPoint(x2, y2));
            po.addPoint(new DPoint(x1, y2));
            po.addPoint(new DPoint(x1, y1));
            DPoint center = new DPoint(0, 0);
            center.x = (bounds[0].x + bounds[1].x) / 2;
            center.y = (bounds[0].y + bounds[1].y) / 2;
            po.setCenter((DPoint) center.clone());
            MM.addObject(po);
        }
    }

    private void processPolyline(Element eec) {
        if (eec.hasAttribute("points") == false) {
            // Erreur irr�cup�rable
            return;
        }
        if (!this.jcbTCPoly.isSelected()) {
            DPoint premierPoint = new DPoint(0, 0);
            DPoint pt = new DPoint(0, 0);
            polyline pl = new polyline();
            polylineSection ps = new polylineSection();
            String points = eec.getAttribute("points");
            Pattern p = Pattern.compile("\\s+");
            Scanner s = new Scanner(points).useDelimiter(p);
            while (s.hasNext()) {
                String e = s.next();
                pt.x = Double.parseDouble(e.substring(0, e.indexOf(",")));
                pt.y = Double.parseDouble(e.substring(e.indexOf(",") + 1));
                verifBounds(pt);
                ps.addPoint((DPoint) pt.clone());
            }
            pl.addSection((polylineSection) ps.clone());
            MM.addObject(pl);
        } else {
            DPolygon po = new DPolygon();
            DPoint premierPoint = new DPoint(Double.MIN_VALUE, Double.MIN_VALUE);
            DPoint pt = new DPoint(0, 0);
            DPoint[] bounds = {new DPoint(Double.MAX_VALUE, Double.MAX_VALUE),
                new DPoint(Double.MIN_VALUE, Double.MIN_VALUE)
            };
            String d = eec.getAttribute("d");
            String points = eec.getAttribute("points");
            Pattern p = Pattern.compile("\\s+");
            Scanner s = new Scanner(points).useDelimiter(p);
            while (s.hasNext()) {
                String e = s.next();
                pt.x = Double.parseDouble(e.substring(0, e.indexOf(",")));
                pt.y = Double.parseDouble(e.substring(e.indexOf(",") + 1));
                if (premierPoint.x == Double.MIN_VALUE) {
                    premierPoint.x = pt.x;
                    premierPoint.y = pt.y;
                }
                verifBoundsP(pt, bounds);
                verifBounds(pt);
                po.addPoint((DPoint) pt.clone());
            }
            DPoint center = new DPoint(0, 0);
            center.x = (bounds[0].x + bounds[1].x) / 2;
            center.y = (bounds[0].y + bounds[1].y) / 2;
            po.setCenter((DPoint) center.clone());
            po.addPoint((DPoint) premierPoint.clone());
            MM.addObject(po);
        }
    }

    private void processPolygon(Element eec) {
        if (eec.hasAttribute("points") == false) {
            // Erreur irr�cup�rable
            return;
        }
        DPoint[] bounds = {new DPoint(Double.MAX_VALUE, Double.MAX_VALUE),
            new DPoint(Double.MIN_VALUE, Double.MIN_VALUE)
        };
        DPoint pt = new DPoint(0, 0);
        DPolygon po = new DPolygon();
        String points = eec.getAttribute("points");
        Pattern p = Pattern.compile("\\s+");
        Scanner s = new Scanner(points).useDelimiter(p);
        while (s.hasNext()) {
            String e = s.next();
            pt.x = Double.parseDouble(e.substring(0, e.indexOf(",")));
            pt.y = Double.parseDouble(e.substring(e.indexOf(",") + 1));
            verifBoundsP(pt, bounds);
            verifBounds(pt);
            po.addPoint((DPoint) pt.clone());
        }
        DPoint center = new DPoint(0, 0);
        center.x = (bounds[0].x + bounds[1].x) / 2;
        center.y = (bounds[0].y + bounds[1].y) / 2;
        po.setCenter(center);
        MM.addObject(po);
    }

    private void processCircle(Element eec) {
        if (eec.hasAttribute("cx") == false) {
            // Erreur irr�cup�rable
            return;
        }
        if (!this.jcbTCPoly.isSelected()) {
            double cx, cy, r, x1, x2, y1, y2;
            cx = Double.parseDouble(eec.getAttribute("cx"));
            cy = Double.parseDouble(eec.getAttribute("cy"));
            r = Double.parseDouble(eec.getAttribute("r"));
            x1 = cx - r;
            y1 = cy - r;
            x2 = cx + r;
            y2 = cy + r;
            verifBounds(new DPoint(x1, y1));
            verifBounds(new DPoint(x2, y2));
            DCircle ci = new DCircle(x1, y1, x2, y2);
            MM.addObject(ci);
        } else {
            double cx, cy, r, x1, x2, y1, y2;
            DPolygon po = new DPolygon();
            DPoint[] bounds = {new DPoint(Double.MAX_VALUE, Double.MAX_VALUE),
                new DPoint(Double.MIN_VALUE, Double.MIN_VALUE)
            };
            cx = Double.parseDouble(eec.getAttribute("cx"));
            cy = Double.parseDouble(eec.getAttribute("cy"));
            r = Double.parseDouble(eec.getAttribute("r"));
            x1 = cx - r;
            y1 = cy - r;
            x2 = cx + r;
            y2 = cy + r;
            verifBoundsP(new DPoint(x1, y1), bounds);
            verifBounds(new DPoint(x1, y1));
            verifBoundsP(new DPoint(x2, y2), bounds);
            verifBounds(new DPoint(x2, y2));
            po.addPoint(new DPoint(x1, y1));
            po.addPoint(new DPoint(x2, y1));
            po.addPoint(new DPoint(x2, y2));
            po.addPoint(new DPoint(x1, y2));
            po.addPoint(new DPoint(x1, y1));
            DPoint center = new DPoint(0, 0);
            center.x = (bounds[0].x + bounds[1].x) / 2;
            center.y = (bounds[0].y + bounds[1].y) / 2;
            po.setCenter((DPoint) center.clone());
            MM.addObject(po);
        }
    }

    private void processEllipse(Element eec) {
        if (eec.hasAttribute("cx") == false) {
            // Erreur irr�cup�rable
            return;
        }
        if (!this.jcbTCPoly.isSelected()) {
            double cx, cy, rx, ry, x1, x2, y1, y2;
            cx = Double.parseDouble(eec.getAttribute("cx"));
            cy = Double.parseDouble(eec.getAttribute("cy"));
            rx = Double.parseDouble(eec.getAttribute("rx"));
            ry = Double.parseDouble(eec.getAttribute("ry"));
            x1 = cx - rx;
            y1 = cy - ry;
            x2 = cx + rx;
            y2 = cy + ry;
            verifBounds(new DPoint(x1, y1));
            verifBounds(new DPoint(x2, y2));
            DCircle ci = new DCircle(x1, y1, x2, y2);
            MM.addObject(ci);
        } else {
            double cx, cy, rx, ry, x1, x2, y1, y2;
            DPolygon po = new DPolygon();
            DPoint[] bounds = {new DPoint(Double.MAX_VALUE, Double.MAX_VALUE),
                new DPoint(Double.MIN_VALUE, Double.MIN_VALUE)
            };
            cx = Double.parseDouble(eec.getAttribute("cx"));
            cy = Double.parseDouble(eec.getAttribute("cy"));
            rx = Double.parseDouble(eec.getAttribute("rx"));
            ry = Double.parseDouble(eec.getAttribute("ry"));
            x1 = cx - rx;
            y1 = cy - ry;
            x2 = cx + rx;
            y2 = cy + ry;
            verifBoundsP(new DPoint(x1, y1), bounds);
            verifBounds(new DPoint(x1, y1));
            verifBoundsP(new DPoint(x2, y2), bounds);
            verifBounds(new DPoint(x2, y2));
            po.addPoint(new DPoint(x1, y1));
            po.addPoint(new DPoint(x2, y1));
            po.addPoint(new DPoint(x2, y2));
            po.addPoint(new DPoint(x1, y2));
            po.addPoint(new DPoint(x1, y1));
            DPoint center = new DPoint(0, 0);
            center.x = (bounds[0].x + bounds[1].x) / 2;
            center.y = (bounds[0].y + bounds[1].y) / 2;
            po.setCenter((DPoint) center.clone());
            MM.addObject(po);
        }
    }

    private void ecriture(String fichierMIF) {
        int i = 0, j = 0, k = 0;
        int coef = 1;
        String qm = new String();
        String fichierMID = fichierMIF.substring(0, fichierMIF.length() - 4) + ".MID";
        qm = "\"";

        if (jcbInversion.isSelected()) {
            coef = -1;
        }
        try {
            // Ecriture MIF
            FileWriter sortie = new FileWriter(fichierMIF);
            BufferedWriter tampon = new BufferedWriter(sortie);
            tampon.write("VERSION 300");
            tampon.newLine();
            tampon.write("Charset " + qm + "WindowsLatin1" + qm);
            tampon.newLine();
            tampon.write("Delimiter " + qm + "," + qm);
            tampon.newLine();
            tampon.write("Unique 1");
            tampon.newLine();
            tampon.write("Index 1");
            tampon.newLine();
            tampon.write("CoordSys Nonearth Units " + qm + "cm" + qm);
            tampon.write(" Bounds (" + MM.getLBound().x + ", " + MM.getLBound().y * coef + ") (" + MM.getHBound().x + ", " + MM.getHBound().y * coef + ")");
            tampon.newLine();
            tampon.write("Columns 2");
            tampon.newLine();
            tampon.write("  code Char(10)");
            tampon.newLine();
            tampon.write("  nom Char(100)");
            tampon.newLine();
            tampon.write("Data");
            tampon.newLine();
            for (i = 0; i < MM.getNumObjets(); i++) {
                if (MM.getObjet(i).getClass() == polyline.class) {
                    polyline pl = (polyline) MM.getObjet(i);
                    if (pl.getNumSections() > 1) {
                        tampon.write("PLINE MULTIPLE " + pl.getNumSections());
                        tampon.newLine();
                        for (j = 0; j < pl.getNumSections(); j++) {
                            polylineSection ps = new polylineSection();
                            ps = pl.getSection(j);
                            tampon.write(" " + ps.getNumPoints());
                            tampon.newLine();
                            for (k = 0; k < ps.getNumPoints(); k++) {
                                tampon.write(ps.getPoint(k).x + " " + ps.getPoint(k).y * coef);
                                tampon.newLine();
                            }
                        }
                    } else {
                        tampon.write("PLINE");
                        polylineSection ps = new polylineSection();
                        ps = pl.getSection(0);
                        tampon.write(" " + ps.getNumPoints());
                        tampon.newLine();
                        for (k = 0; k < ps.getNumPoints(); k++) {
                            tampon.write(ps.getPoint(k).x + " " + ps.getPoint(k).y * coef);
                            tampon.newLine();
                        }
                    }
                }
                if (MM.getObjet(i).getClass() == DRect.class) {
                    DRect r = new DRect();
                    r = (DRect) MM.getObjet(i);
                    tampon.write("RECT " + r.getX1() + " " + r.getY1() * coef + " " + r.getX2() + " " + r.getY2() * coef);
                    tampon.newLine();
                }
                if (MM.getObjet(i).getClass() == DLine.class) {
                    DLine l = new DLine();
                    l = (DLine) MM.getObjet(i);
                    tampon.write("LINE " + l.getX1() + " " + l.getY1() * coef + " " + l.getX2() + " " + l.getY2() * coef);
                    tampon.newLine();
                }
                if (MM.getObjet(i).getClass() == DPolygon.class) {
                    tampon.write("REGION 1");
                    tampon.newLine();
                    DPolygon po = new DPolygon();
                    po = (DPolygon) MM.getObjet(i);
                    tampon.write(" " + po.getNumPoints());
                    tampon.newLine();
                    for (k = 0; k < po.getNumPoints(); k++) {
                        tampon.write(po.getPoint(k).x + " " + po.getPoint(k).y * coef);
                        tampon.newLine();
                    }
                    tampon.write("Center " + po.getCenter().x + " " + po.getCenter().y * coef);
                    tampon.newLine();
                }
                if (MM.getObjet(i).getClass() == DCircle.class) {
                    DCircle ci = new DCircle();
                    ci = (DCircle) MM.getObjet(i);
                    tampon.write("ELLIPSE " + ci.getX1() + " " + ci.getY1() * coef + " " + ci.getX2() + " " + ci.getY2() * coef);
                    tampon.newLine();
                }
            }
            tampon.close();
            sortie.close();

            // Ecriture MID
            sortie = new FileWriter(fichierMID);
            tampon = new BufferedWriter(sortie);
            for (i = 0; i < MM.getNumObjets(); i++) {
                tampon.write("" + qm + i + qm + "," + qm + MM.getObjet(i).getClass().toString() + i + qm);
                tampon.newLine();
            }
            tampon.close();
            sortie.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void verifBounds(DPoint pt) {
        if (pt.x < MM.getLBound().x) {
            MM.setBoundX(0, pt.x);
        }
        if (pt.y < MM.getLBound().y) {
            MM.setBoundY(0, pt.y);
        }
        if (pt.x > MM.getHBound().x) {
            MM.setBoundX(1, pt.x);
        }
        if (pt.y > MM.getHBound().y) {
            MM.setBoundY(1, pt.y);
        }
    }

    private void verifBoundsP(DPoint pt, DPoint[] bounds) {
        if (pt.x < bounds[0].x) {
            bounds[0].x = pt.x;
        }
        if (pt.y < bounds[0].y) {
            bounds[0].y = pt.y;
        }
        if (pt.x > bounds[1].x) {
            bounds[1].x = pt.x;
        }
        if (pt.y > bounds[1].y) {
            bounds[1].y = pt.y;
        }
    }

    private double getValueFromSize(String taille) {
        int l = taille.length();
        if (taille.substring(l - 1).equals("%")) {
            return Integer.parseInt(taille.substring(0, l - 1));
        } else if (taille.substring(l - 1).matches("[0-9]")) {
            return Double.parseDouble(taille);
        } else {
            return Integer.parseInt(taille.substring(0, l - 2));
        }
    }

    private String getUnitFromSize(String taille) {
        int l = taille.length();
        if (taille.substring(l - 1).equals("%")) {
            return "%";
        } else {
            return taille.substring(l - 2);
        }
    }
}
